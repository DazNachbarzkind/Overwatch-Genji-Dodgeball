settings
{
	main
	{
		Description: "Genji Dodgeball v6.0.0. Developed by u/Mazawath. Numerous updates by u/FearlessKat, u/Blink, u/TheRedstoneBlaze,  ELIMINATED#1572, and tumtum9000#1232. Deflect the ball when it is red to target someone else! Use jump pads to get air!"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: After A Game
		Match Voice Chat: Enabled
		Max Spectators: 6
		Return To Lobby: Never
		Swap Teams After Match: No
	}

	modes
	{
		Deathmatch
		{
			Game Length In Minutes: 15
			Self Initiated Respawn: Off

			enabled maps
			{
				Workshop Island Night
			}
		}

		disabled Team Deathmatch
		{
			Game Length In Minutes: 15
			Imbalanced Team Score To Win: On
			Team 1 Score To Win: 10
			Team 2 Score To Win: 10
		}

		General
		{
			Allow Hero Switching: Off
			Game Mode Start: Immediately
			Hero Limit: Off
			Respawn As Random Hero: On
		}
	}

	heroes
	{
		General
		{
			Genji
			{
				Deflect Cooldown Time: 0%
				No Ammunition Requirement: On
				Primary Fire: Off
				Quick Melee: Off
				Secondary Fire: Off
				Swift Strike Cooldown Time: 34%
				Ultimate Generation - Combat Dragonblade: 0%
				Ultimate Generation - Passive Dragonblade: 0%
			}

			enabled heroes
			{
				Genji
			}
		}
	}

	extensions
	{
		Buff and Debuff Sounds
		Kinetic Explosion Effects
		Explosion Sounds
	}
}

variables
{
	global:
		0: SlotOfTargetedPlayer
		1: SlotOfPreviousTargetedPlayer
		2: BallSpeed
		3: BallPosition
		4: BallSpawnCountdown
		5: BallIsOut
		6: BallDeleteRequested
		7: RoundInProgress
		8: BouncePadCooldownLength
		9: BallSpawnSpeed
		10: MaxBallSpeed
		11: IsInFinalDuel
		12: BallSpawnCountdownHUD
		13: BouncePadDistance
		14: BouncePadStrength
		15: BouncePad1
		16: BouncePad2
		17: BouncePad3
		18: BouncePad4
		19: deathSphere
		20: deathSphereRad
		21: IsEnoughPlayersToStart
		22: WaitingForPlayersHUD
		23: CenterOffLimitsSize
		24: SphereSize
		25: CircleCenter
		26: RedGreenColorblindMode
		27: WatermarkEnabled
		28: BouncepadDashingEnabled
		29: GameEndEnabled
		30: CooldownDashingEnabled
		31: deathSpherePos
		32: deathBeam
		33: BallDirection
		34: BallCollisionSurfaceNormal
		35: PrevBallPos
		36: PrevBallPos2
		37: BallSmoke
		38: BallTail1
		39: BallTail2
		40: BallColor
		41: HighestScore
		42: TieBreakerActive
		43: RandomExplosionPicker
		44: ExplosionSoundVolume
		45: ImprovedExplosions
		46: RandomExplosionSounds
		47: FinalDuelNuke
		51: AllowMatchEnd
		52: PassingDamage
		53: IsPassingTeam1
		54: IsPassingTeam2
		55: ScoreToWin
		56: PassingEnabled
		57: BouncePadSuperjumpNerf

	player:
		0: hasMoved
		1: CurrentUltPercent
		2: BouncePadCooldown
		4: PlayerDeflects
		5: PlayerKills
		6: PlayerDeaths
		7: PlayerEffects
		9: IsDashEnabled
		10: moveSpeed
		11: maxBallSpeed
		12: antiFloatProtection
		13: antiFloatTimer
		14: antiStuckProtection
		15: ToggleHUD
		16: DashNerf
}

subroutines
{
	0: CoolDeathEffects
	1: UpdatedDeathEffects
	2: DeflectFailed
}

rule("// SETTINGS")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.PassingEnabled = Workshop Setting Toggle(Custom String("Dodgeball Settings"), Custom String("Passing Enabled"), False, 0);
		Global.AllowMatchEnd = Workshop Setting Toggle(Custom String("Teams Settings"), Custom String("Allow Match to End At Score"), True,
			0);
		Global.ScoreToWin = Workshop Setting Integer(Custom String("Teams Settings"), Custom String("Score to Win"), 10, 1, 30, 1);
		"Currently, there is an issue where the server will end, based on how many players there are. If there are less it will take longer to crash. But it WILL crash. This rule simply lets there be a \"winner\" at the end VS crashing in the middle of Final Duel."
		Global.GameEndEnabled = Workshop Setting Toggle(Custom String("Teams Settings"), Custom String("Allow Match to End At Time"),
			False, 2);
		Global.WatermarkEnabled = Workshop Setting Toggle(Custom String("Visual Settings"), Custom String("Enable Watermark"), True, 0);
		Global.CooldownDashingEnabled = True;
		Global.RedGreenColorblindMode = Workshop Setting Toggle(Custom String("Visual Settings"), Custom String(
			"Red/Green Colorblind Mode"), False, 2);
		Global.FinalDuelNuke = Workshop Setting Toggle(Custom String("Visual Settings"), Custom String("Final Duel Explosion"), True, 3);
	}
}

rule("// MAP ZONES")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.SlotOfTargetedPlayer = 0;
	}
}

rule("Set Workshop Island")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		Global.CircleCenter = Vector(0, 1.199, 0);
		Global.SphereSize = 60;
	}
}

rule("Set Workshop Chamber")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Workshop Chamber);
	}

	actions
	{
		Global.CircleCenter = Vector(0, 1.199, 0);
		Global.SphereSize = 29.700;
	}
}

rule("Set Workshop Expanse Center")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Workshop Expanse);
	}

	actions
	{
		Global.CircleCenter = Vector(0, 1.199, 0);
		Global.SphereSize = 20;
	}
}

rule("Set Oasis University Center")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Oasis University);
	}

	actions
	{
		Global.CircleCenter = Vector(-192.609, 60.349, 2.252);
		Global.SphereSize = 20;
	}
}

rule("Set Kings Row center (NOTE: Lower the max players! This arena is smaller then the others!)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(King's Row);
	}

	actions
	{
		Global.CircleCenter = Vector(-20.504, 40.538, -74.601);
		Global.SphereSize = 17;
	}
}

rule("Set Blizz World center (fun fact: you can't use the name of the company who made this game in rule names)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Blizzard World);
	}

	actions
	{
		Global.CircleCenter = Vector(2.554, -4.651, -71.211);
		Global.SphereSize = 20;
	}
}

rule("Init player variables")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.IsDashEnabled = False;
		Set Status(Event Player, Null, Invincible, 9999);
		Skip If(Global.CooldownDashingEnabled, 1);
		Set Ability 1 Enabled(Event Player, False);
		Disable Built-In Game Mode Respawning(Event Player);
		Enable Death Spectate All Players(Event Player);
		Event Player.BouncePadCooldown = Global.BouncePadCooldownLength;
		Event Player.antiFloatProtection = False;
		Event Player.antiStuckProtection = False;
		Event Player.ToggleHUD = True;
		Event Player.DashNerf = False;
		Wait Until(Is Alive(Event Player) && Is Game In Progress, 90);
		Wait(3, Ignore Condition);
		Small Message(Event Player, Custom String("Press interact to enable/disable the scoreboard"));
	}
}

rule("Init global variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.SlotOfTargetedPlayer = -1;
		Global.SlotOfPreviousTargetedPlayer = -1;
		Global.BallSpawnCountdown = 3;
		Disable Built-In Game Mode Scoring;
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Music;
		Disable Built-In Game Mode Announcer;
		Global.BouncePadStrength = 30;
		Global.BouncePadDistance = 12;
		Global.BallSpeed = 30;
		Global.BallSpawnSpeed = 30;
		Global.MaxBallSpeed = 1000;
		Global.CenterOffLimitsSize = 3.500;
		Global.IsInFinalDuel = False;
		Global.BouncePadCooldownLength = 3;
		Global.BouncePadSuperjumpNerf = 6;
		Global.BallPosition = Vector(0, -1, 0);
		Global.ExplosionSoundVolume = 30;
		Global.ImprovedExplosions = True;
		Global.RandomExplosionSounds = True;
		Global.CooldownDashingEnabled = True;
		Global.PassingDamage = 100;
		Global.IsPassingTeam1 = False;
		Global.IsPassingTeam2 = False;
		If(Current Game Mode == Game Mode(Deathmatch));
			Global.GameEndEnabled = True;
	}
}

rule("Create game sphere")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create Effect(All Players(All Teams), Sphere, Color(Black), Vector(X Component Of(Global.CircleCenter), Y Component Of(
			Global.CircleCenter), Z Component Of(Global.CircleCenter)), Global.CenterOffLimitsSize, Visible To Position and Radius);
		"Workshop Island doesn't need a circle."
		If(Current Map != Map(Workshop Island) && Current Map != Map(Workshop Island Night));
			Create Effect(All Players(All Teams), Light Shaft, Color(Orange), Vector(X Component Of(Global.CircleCenter), Y Component Of(
				Global.CircleCenter) - 15, Z Component Of(Global.CircleCenter)), Global.SphereSize, Visible To Position and Radius);
		Else;
			Create Effect(Filtered Array(All Players(All Teams), Distance Between(Position Of(Current Array Element), Global.CircleCenter)
				>= Global.SphereSize - 10), Light Shaft, Color(Blue), Vector(X Component Of(Global.CircleCenter), Y Component Of(
				Global.CircleCenter) - 15, Z Component Of(Global.CircleCenter)), Global.SphereSize, Visible To Position and Radius);
	}
}

rule("Create global HUD elements")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"white normal"
		Create HUD Text(Remove From Array(All Players(All Teams), Global.SlotOfTargetedPlayer), Null, Null, Custom String(
			"Current Player Targeted: {0}", Global.SlotOfTargetedPlayer), Left, -2, Null, Null, Color(White), Visible To and String,
			Default Visibility);
		"red when you're targeted"
		Create HUD Text(Global.SlotOfTargetedPlayer, Null, Null, Custom String("Current Player Targeted: {0}",
			Global.SlotOfTargetedPlayer), Left, -2, Null, Null, Color(Red), Visible To and String, Default Visibility);
		Create HUD Text(All Dead Players(All Teams), Custom String("Waiting for next round"), Custom String(
			"You have been eliminated or joined during a round"), Custom String("You will spawn once the next round starts"), Top, 2,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		"pass"
		disabled Abort;
		"hudSubtext(getAllPlayers(), \"If you get hit, you die.  Last man standing wins!\", HudPosition.RIGHT, -9, Color.WHITE, HudReeval.VISIBILITY_AND_STRING, SpecVisibility.DEFAULT)\r\nball speed text color change with speed"
		Create HUD Text(Global.BallSpeed < 20 ? All Players(All Teams) : Empty Array, Null, Null, Custom String("Current Ball Speed: {0}",
			Global.BallSpeed), Left, -3, Null, Null, Color(Blue), Visible To and String, Default Visibility);
		Create HUD Text(Global.BallSpeed >= 20 && Global.BallSpeed < 25 ? All Players(All Teams) : Empty Array, Null, Null, Custom String(
			"Current Ball Speed: {0}", Global.BallSpeed), Left, -3, Null, Null, Color(Green), Visible To and String, Default Visibility);
		Create HUD Text(Global.BallSpeed >= 25 && Global.BallSpeed < 30 ? All Players(All Teams) : Empty Array, Null, Null, Custom String(
			"Current Ball Speed: {0}", Global.BallSpeed), Left, -3, Null, Null, Color(Yellow), Visible To and String, Default Visibility);
		Create HUD Text(Global.BallSpeed >= 30 && Global.BallSpeed < 35 ? All Players(All Teams) : Empty Array, Null, Null, Custom String(
			"Current Ball Speed: {0}", Global.BallSpeed), Left, -3, Null, Null, Color(Orange), Visible To and String, Default Visibility);
		Create HUD Text(Global.BallSpeed >= 35 && Global.BallSpeed < 55 ? All Players(All Teams) : Empty Array, Null, Null, Custom String(
			"Current Ball Speed: {0}", Global.BallSpeed), Left, -3, Null, Null, Color(Red), Visible To and String, Default Visibility);
		Create HUD Text(Global.BallSpeed > 55 ? All Players(All Teams) : Empty Array, Null, Null, Custom String("Current Ball Speed: {0}",
			Global.BallSpeed), Left, -3, Null, Null, Color(Purple), Visible To and String, Default Visibility);
		"hudSubheader(getAllPlayers(), \"Updates by u/FearlessKat, u/Blink, u/TheRedstoneBlaze, tumtum9000#1232,david8686406#1523\", HudPosition.LEFT, -10, Color.WHITE, HudReeval.VISIBILITY_AND_STRING, SpecVisibility.DEFAULT)"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Discord.gg/GenjiDodgeball"), Left, 0, Null, Null, Color(White),
			Visible To and String, Default Visibility);
		If(Global.PassingEnabled);
			If(Current Game Mode == Game Mode(Team Deathmatch));
				Create HUD Text(All Players(All Teams), Null, Null, Custom String(
					"Hold secondary fire while deflecting to pass the ball to another teammate!"), Right, 0, Null, Null, Color(White),
					Visible To and String, Default Visibility);
			Else If(Current Game Mode == Game Mode(Deathmatch));
				Create HUD Text(All Players(All Teams), Null, Null, Custom String("Hold secondary fire while deflecting to self pass the ball!"),
					Right, 0, Null, Null, Color(White), Visible To and String, Default Visibility);
	}
}

rule("Create bounce pads")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.BouncePad1 = Vector(X Component Of(Global.CircleCenter) + Global.BouncePadDistance, Y Component Of(Global.CircleCenter),
			Z Component Of(Global.CircleCenter));
		Global.BouncePad2 = Vector(X Component Of(Global.CircleCenter) + Global.BouncePadDistance * -1, Y Component Of(
			Global.CircleCenter), Z Component Of(Global.CircleCenter));
		Global.BouncePad3 = Vector(X Component Of(Global.CircleCenter), Y Component Of(Global.CircleCenter), Z Component Of(
			Global.CircleCenter) + Global.BouncePadDistance);
		Global.BouncePad4 = Vector(X Component Of(Global.CircleCenter), Y Component Of(Global.CircleCenter), Z Component Of(
			Global.CircleCenter) + Global.BouncePadDistance * -1);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown == 0), Ring, Color(Sky Blue),
			Global.BouncePad1, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown == 0), Ring, Color(Sky Blue),
			Global.BouncePad2, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown == 0), Ring, Color(Sky Blue),
			Global.BouncePad3, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown == 0), Ring, Color(Sky Blue),
			Global.BouncePad4, 2, Visible To Position and Radius);
		Skip If(Global.RedGreenColorblindMode, 5);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(White),
			Global.BouncePad1, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(White),
			Global.BouncePad2, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(White),
			Global.BouncePad3, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(White),
			Global.BouncePad4, 2, Visible To Position and Radius);
		Abort;
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(Yellow),
			Global.BouncePad1, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(Yellow),
			Global.BouncePad2, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(Yellow),
			Global.BouncePad3, 2, Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element.BouncePadCooldown > 0), Ring, Color(Yellow),
			Global.BouncePad4, 2, Visible To Position and Radius);
	}
}

rule("Create ball & targeted effect")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Current Game Mode == Game Mode(Deathmatch);
	}

	actions
	{
		"Orb for when ball is not getting passed"
		Create Effect(Remove From Array(All Players(All Teams), Global.SlotOfTargetedPlayer), Orb, Color(White), Global.BallPosition,
			0.400, Visible To Position and Radius);
		"Orb for when ball is getting passed"
		Create Effect(Global.IsPassingTeam1 ? Global.SlotOfTargetedPlayer : Empty Array, Orb, Color(Sky Blue), Global.BallPosition, 0.400,
			Visible To Position and Radius);
		If(!Global.RedGreenColorblindMode);
			Create Effect(Global.IsPassingTeam1 ? Empty Array : Global.SlotOfTargetedPlayer, Orb, Color(Red), Global.BallPosition, 0.400,
				Visible To Position and Radius);
			Create Effect(Remove From Array(All Players(All Teams), Global.SlotOfTargetedPlayer), Good Aura, Color(Red),
				Global.SlotOfTargetedPlayer, 1, Visible To Position and Radius);
			Create Effect(Global.SlotOfTargetedPlayer, Good Aura, Color(Red), Global.SlotOfTargetedPlayer, 1, Visible To Position and Radius);
			Create Effect(Global.SlotOfTargetedPlayer, Good Aura, Color(Red), Global.BallPosition, 1, Visible To Position and Radius);
		Else;
			Create Effect(Global.SlotOfTargetedPlayer, Orb, Color(Yellow), Global.BallPosition, 0.400, Visible To Position and Radius);
			Create Effect(All Players(All Teams), Good Aura, Color(Yellow), Global.SlotOfTargetedPlayer, 1, Visible To Position and Radius);
			Create Effect(Global.SlotOfTargetedPlayer, Good Aura, Color(Yellow), Eye Position(Global.SlotOfTargetedPlayer), 1,
				Visible To Position and Radius);
		End;
		"BallTail1 = getLastCreatedEntity()\r\ncreateBeam(getAllPlayers(), Beam.BAD, PrevBallPos, PrevBallPos2, Color.BLUE, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)\r\nBallTail2 = getLastCreatedEntity()"
		Create Effect(Global.IsPassingTeam1 || Global.IsPassingTeam2 ? Remove From Array(All Players(All Teams),
			Global.SlotOfTargetedPlayer) : Empty Array, Good Aura, Color(Sky Blue), Global.BallPosition, 1,
			Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element != Global.SlotOfTargetedPlayer && (
			Global.IsPassingTeam1 || Global.IsPassingTeam2)), Good Aura, Color(Sky Blue), Global.SlotOfTargetedPlayer, 1,
			Visible To Position and Radius);
	}
}

rule("Create ball & targeted effect - TEAMS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		"Team 1 standard ball"
		Create Effect(Filtered Array(All Players(Team 1), Current Array Element != Global.SlotOfTargetedPlayer && !Global.IsPassingTeam1),
			Orb, Color(White), Global.BallPosition, 0.400, Visible To Position and Radius);
		"Team 1 passing ball"
		Create Effect(Global.IsPassingTeam1 ? All Players(Team 1) : Empty Array, Orb, Color(Sky Blue), Global.BallPosition, 0.400,
			Visible To Position and Radius);
		"Team 2 standard ball"
		Create Effect(Filtered Array(All Players(Team 2), Current Array Element != Global.SlotOfTargetedPlayer && !Global.IsPassingTeam2),
			Orb, Color(White), Global.BallPosition, 0.400, Visible To Position and Radius);
		"Team 2 passing ball"
		Create Effect(Global.IsPassingTeam2 ? All Players(Team 2) : Empty Array, Orb, Color(Sky Blue), Global.BallPosition, 0.400,
			Visible To Position and Radius);
		If(!Global.RedGreenColorblindMode);
			"Team 1 Targeted Ball"
			Create Effect(!Global.IsPassingTeam1 && !Global.IsPassingTeam2 ? Global.SlotOfTargetedPlayer : Empty Array, Orb, Color(Red),
				Global.BallPosition, 0.400, Visible To Position and Radius);
			"Team 2 Targeted Ball\r\ncreateEffect([i for i in SlotOfTargetedPlayer if not IsPassingTeam2], Effect.ORB, Color.RED, BallPosition, 0.4, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)"
			Create Effect(Remove From Array(All Players(All Teams), Global.SlotOfTargetedPlayer), Good Aura, Color(Red),
				Global.SlotOfTargetedPlayer, 1, Visible To Position and Radius);
			Create Effect(Global.SlotOfTargetedPlayer, Good Aura, Color(Red), Global.SlotOfTargetedPlayer, 1, Visible To Position and Radius);
			Create Effect(Global.SlotOfTargetedPlayer, Good Aura, Color(Red), Global.BallPosition, 1, Visible To Position and Radius);
		Else;
			Create Effect(Global.SlotOfTargetedPlayer, Orb, Color(Yellow), Global.BallPosition, 0.400, Visible To Position and Radius);
			Create Effect(All Players(All Teams), Good Aura, Color(Yellow), Global.SlotOfTargetedPlayer, 1, Visible To Position and Radius);
			Create Effect(Global.SlotOfTargetedPlayer, Good Aura, Color(Yellow), Eye Position(Global.SlotOfTargetedPlayer), 1,
				Visible To Position and Radius);
		End;
		"BallTail1 = getLastCreatedEntity()\r\ncreateBeam(getAllPlayers(), Beam.BAD, PrevBallPos, PrevBallPos2, Color.BLUE, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)\r\nBallTail2 = getLastCreatedEntity()"
		Create Effect(Global.IsPassingTeam1 || Global.IsPassingTeam2 ? Remove From Array(All Players(All Teams),
			Global.SlotOfTargetedPlayer) : Empty Array, Good Aura, Color(Sky Blue), Global.BallPosition, 1,
			Visible To Position and Radius);
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element != Global.SlotOfTargetedPlayer && (
			Global.IsPassingTeam1 || Global.IsPassingTeam2)), Good Aura, Color(Sky Blue), Global.SlotOfTargetedPlayer, 1,
			Visible To Position and Radius);
	}
}

rule("Create ball countdown HUD")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BallSpawnCountdown > 0;
	}

	actions
	{
		Create In-World Text(All Players(All Teams), Custom String("Ball Spawning In: {0}", Round To Integer(Global.BallSpawnCountdown,
			Up)), Vector(X Component Of(Global.CircleCenter), Y Component Of(Global.CircleCenter) + 2.500, Z Component Of(
			Global.CircleCenter)), 2.500, Clip Against Surfaces, Visible To Position and String, Color(Sky Blue), Default Visibility);
		Global.BallSpawnCountdownHUD = Last Text ID;
	}
}

rule("Delete ball countdown HUD")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BallSpawnCountdown == 0;
	}

	actions
	{
		Destroy In-World Text(Global.BallSpawnCountdownHUD);
	}
}

rule("Enable Scoreboard")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Event Player.ToggleHUD == True;
	}

	actions
	{
		Disable Game Mode HUD(Event Player);
		Wait Until(!Is Button Held(Event Player, Button(Interact)), 10);
		Event Player.ToggleHUD = False;
	}
}

rule("Disable Scoreboard")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Event Player.ToggleHUD == False;
	}

	actions
	{
		Enable Game Mode HUD(Event Player);
		Wait Until(!Is Button Held(Event Player, Button(Interact)), 10);
		Event Player.ToggleHUD = True;
	}
}

rule("// Not enough players testing")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Skip If(!Global.WatermarkEnabled, 1);
		Create HUD Text(All Players(All Teams), Null, Custom String("Original by u/Mazawrath. Version v6.0.0"), Null, Left, -1000, Null,
			Color(Aqua), Null, Visible To and String, Visible Always);
	}
}

rule("Check for <2 players")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Number Of Players(All Teams) == 1;
		Current Game Mode == Game Mode(Deathmatch);
	}

	actions
	{
		Global.IsInFinalDuel = False;
		Create HUD Text(All Players(All Teams), Custom String("Waiting for more players"), Null, Null, Top, 0, Color(White), Null, Null,
			Visible To and String, Default Visibility);
		Global.WaitingForPlayersHUD = Last Text ID;
		Global.IsEnoughPlayersToStart = False;
		Stop Chasing Global Variable(BallSpawnCountdown);
		Skip If(Global.RoundInProgress == False, 1);
		Global.BallDeleteRequested = True;
		Global.RoundInProgress = False;
		Pause Match Time;
	}
}

rule("Check for <2 players - TEAMS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		"@Condition getNumberOfPlayers(Team.ALL) == 1"
		(Number Of Players(Team 1) && Number Of Players(Team 2)) == False;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		Global.IsInFinalDuel = False;
		Create HUD Text(All Players(All Teams), Custom String("Waiting for more players"), Null, Null, Top, 0, Color(White), Null, Null,
			Visible To and String, Default Visibility);
		Global.WaitingForPlayersHUD = Last Text ID;
		Global.IsEnoughPlayersToStart = False;
		Stop Chasing Global Variable(BallSpawnCountdown);
		Skip If(Global.RoundInProgress == False, 1);
		Global.BallDeleteRequested = True;
		Global.RoundInProgress = False;
		Pause Match Time;
	}
}

rule("Wait for more players")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Number Of Players(All Teams) > 1;
		Global.IsEnoughPlayersToStart == False;
		Current Game Mode == Game Mode(Deathmatch);
	}

	actions
	{
		Destroy HUD Text(Global.WaitingForPlayersHUD);
		Big Message(All Players(All Teams), Custom String("Starting game in 5 seconds!"));
		Wait(5.500, Ignore Condition);
		Abort If(Number Of Players(All Teams) < 2);
		Unpause Match Time;
		Global.IsEnoughPlayersToStart = True;
		Global.SlotOfTargetedPlayer = -1;
		Global.SlotOfPreviousTargetedPlayer = -1;
	}
}

rule("Wait for more players - TEAMS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Number Of Players(Team 1) != False;
		Number Of Players(Team 2) != False;
		Global.IsEnoughPlayersToStart == False;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		Destroy HUD Text(Global.WaitingForPlayersHUD);
		Big Message(All Players(All Teams), Custom String("Starting game in 5 seconds!"));
		Wait(5.500, Ignore Condition);
		Abort If(Number Of Players(All Teams) < 2);
		Unpause Match Time;
		Global.IsEnoughPlayersToStart = True;
		Global.SlotOfTargetedPlayer = -1;
		Global.SlotOfPreviousTargetedPlayer = -1;
	}
}

rule("Player joins game")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hasMoved == False;
		"@Condition isGameInProgress() == true"
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Skip If(!Global.RoundInProgress || !Is Game In Progress, 1);
		Kill(Event Player, Null);
		Teleport(Event Player, Global.CircleCenter + Vector(Random Integer(-10, 10), 8, Random Integer(-10, 10)));
		Event Player.hasMoved = True;
	}
}

rule("Shorten Deflect Length")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Wait(0.300, Ignore Condition);
		Set Ability 2 Enabled(Event Player, False);
		Set Ability 1 Enabled(Event Player, False);
		Wait(0.500, Ignore Condition);
		Set Ability 2 Enabled(Event Player, True);
		Set Ability 1 Enabled(Event Player, True);
	}
}

rule("Unlock dash after using jumppad")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.BouncepadDashingEnabled == True;
		Event Player.IsDashEnabled == True;
	}

	actions
	{
		Set Ability 1 Enabled(Event Player, True);
	}
}

rule("Disable dash after using")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.BouncepadDashingEnabled == True;
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Ability 1 Enabled(Event Player, False);
		Event Player.IsDashEnabled = False;
	}
}

rule("Target random player")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.SlotOfTargetedPlayer == -1;
	}

	actions
	{
		Global.SlotOfTargetedPlayer = Random Value In Array(Filtered Array(All Living Players(All Teams),
			Current Array Element.hasMoved && Global.SlotOfPreviousTargetedPlayer != Players In Slot(Current Array Element, All Teams)));
	}
}

rule("Push to circle")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Vector(X Component Of(Global.CircleCenter), Y Component Of(Position Of(Event Player)),
			Z Component Of(Global.CircleCenter))) > Global.SphereSize - 1.500;
		"Workshop Island Fix"
		Current Map != Map(Workshop Island);
		Current Map != Map(Workshop Island Night);
	}

	actions
	{
		Apply Impulse(Event Player, Vector(X Component Of(Direction Towards(Position Of(Event Player), Global.CircleCenter)), 0,
			Z Component Of(Direction Towards(Position Of(Event Player), Global.CircleCenter))), 6, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Up, 3, To World, Incorporate Contrary Motion);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Put out center")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.CircleCenter) < Global.CenterOffLimitsSize + 0.500;
	}

	actions
	{
		Apply Impulse(Event Player, Direction Towards(Global.CircleCenter, Event Player), 10, To World, Cancel Contrary Motion XYZ);
		Apply Impulse(Event Player, Up, 1.500, To World, Cancel Contrary Motion XYZ);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Player dashes too far out of bounds")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Vector(X Component Of(Global.CircleCenter), Y Component Of(Position Of(Event Player)),
			Z Component Of(Global.CircleCenter))) > Global.SphereSize + 1;
	}

	actions
	{
		"Workshop Island Fix\r\n@Condition (getCurrentMap() != Map.WORKSHOP_ISLAND and getCurrentMap() != Map.WORKSHOP_ISLAND_NIGHT) == true"
		Set Status(Event Player, Null, Knocked Down, 2.500);
		"eventPlayer.teleport(CircleCenter + vect(random.randint(-15, 15), 8, random.randint(-15, 15)))"
		Apply Impulse(Event Player, Vector(X Component Of(Direction Towards(Position Of(Event Player), Global.CircleCenter)), 0,
			Z Component Of(Direction Towards(Position Of(Event Player), Global.CircleCenter))), 20, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Up, 3, To World, Cancel Contrary Motion);
		Big Message(Event Player, Custom String("Do not dash out of the arena!"));
	}
}

rule("Player tries to abuse ledge on Workshop Island (push up and to center)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < -0.500;
		Is Alive(Event Player) == True;
		"Workshop Island Fix"
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		"Prevents people from going under the ledge on Workshop Island, which caused ball to go into floor.  Used to be an annoying stunkill"
		Apply Impulse(Event Player, Up, 2, To World, Cancel Contrary Motion);
		Apply Impulse(Event Player, Direction Towards(Event Player, Global.CircleCenter), 2, To World, Incorporate Contrary Motion);
		Wait(0.008, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Player falls off Workshop Island")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
		Y Component Of(Position Of(Event Player)) < -0.250;
	}

	actions
	{
		"A MAN HAS FALLEN INTO THE LAKE IN WORKSHOP ISLAND! START THE NEW RESCUE RULE! HEY! BUILD THE NEW WORSHOP RULE, AND OFF TO THE RESCUE! PREPARE THE CONDITION, TELEPORT THE PLAYER, AND MAKE THE RESCUE! THE NEW 2.3.0 UPDATE FROM OVERWATCH WORKSHOP!"
		If(Is Dead(Event Player));
			Teleport(Event Player, Global.CircleCenter + Vector(Random Integer(-10, 10), 8, Random Integer(-10, 10)));
			If(Event Player == Global.SlotOfTargetedPlayer);
				If(Global.BallIsOut);
					Global.BallDeleteRequested = True;
				End;
			End;
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Anti-Bounce Detection Positive X")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < 0;
		X Component Of(Position Of(Event Player)) > 20.500;
		"Workshop Island Fix"
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, antiFloatTimer, 0.010, 1, Destination and Rate);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		"Busted!"
		Event Player.antiFloatProtection = True;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Anti-Bounce Detection Netgative X")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < 0;
		X Component Of(Position Of(Event Player)) < -20.500;
		"Workshop Island Fix"
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, antiFloatTimer, 0.010, 1, Destination and Rate);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		"Busted!"
		Event Player.antiFloatProtection = True;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Anti-Bounce Detection Positive Z")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < 0;
		Z Component Of(Position Of(Event Player)) > 20.500;
		"Workshop Island Fix"
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, antiFloatTimer, 0.010, 1, Destination and Rate);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		"Busted!"
		Event Player.antiFloatProtection = True;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Anti-Bounce Detection Negative Z")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < 0;
		Z Component Of(Position Of(Event Player)) < -20.500;
		"Workshop Island Fix"
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, antiFloatTimer, 0.010, 1, Destination and Rate);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		"Busted!"
		Event Player.antiFloatProtection = True;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Disable Anti-Bounce")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) >= 0;
		Event Player.antiFloatProtection == True;
		"Workshop Island Fix"
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		Event Player.antiFloatProtection = False;
	}
}

rule("Anti-Stuck Activation")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Y Component Of(Position Of(Event Player)) < -4;
		(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night)) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Up, 5, To World, Cancel Contrary Motion XYZ);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bounce when near pad 1")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.BouncePad1) <= 2.750;
		Event Player.BouncePadCooldown == 0;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Has Status(Event Player, Knocked Down) == False;
	}

	actions
	{
		Event Player.IsDashEnabled = True;
		If(Event Player.DashNerf);
			Apply Impulse(Event Player, Up, Global.BouncePadStrength - Global.BouncePadSuperjumpNerf, To World, Cancel Contrary Motion);
		Else;
			Apply Impulse(Event Player, Up, Global.BouncePadStrength, To World, Cancel Contrary Motion);
		End;
		Event Player.BouncePadCooldown = Global.BouncePadCooldownLength;
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Global.BouncePad1, 25);
		Event Player.PlayerEffects[1] = Last Created Entity;
		Wait(2, Ignore Condition);
		Destroy Effect(Event Player.PlayerEffects[1]);
	}
}

rule("Bounce when near pad 2")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.BouncePad2) <= 2.750;
		Event Player.BouncePadCooldown == 0;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Has Status(Event Player, Knocked Down) == False;
	}

	actions
	{
		Event Player.IsDashEnabled = True;
		If(Event Player.DashNerf);
			Apply Impulse(Event Player, Up, Global.BouncePadStrength - Global.BouncePadSuperjumpNerf, To World, Cancel Contrary Motion);
		Else;
			Apply Impulse(Event Player, Up, Global.BouncePadStrength, To World, Cancel Contrary Motion);
		End;
		Event Player.BouncePadCooldown = Global.BouncePadCooldownLength;
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Global.BouncePad1, 25);
		Event Player.PlayerEffects[1] = Last Created Entity;
		Wait(2, Ignore Condition);
		Destroy Effect(Event Player.PlayerEffects[1]);
	}
}

rule("Bounce when near pad 3")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.BouncePad3) <= 2.750;
		Event Player.BouncePadCooldown == 0;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Has Status(Event Player, Knocked Down) == False;
	}

	actions
	{
		Event Player.IsDashEnabled = True;
		If(Event Player.DashNerf);
			Apply Impulse(Event Player, Up, Global.BouncePadStrength - Global.BouncePadSuperjumpNerf, To World, Cancel Contrary Motion);
		Else;
			Apply Impulse(Event Player, Up, Global.BouncePadStrength, To World, Cancel Contrary Motion);
		End;
		Event Player.BouncePadCooldown = Global.BouncePadCooldownLength;
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Global.BouncePad1, 25);
		Event Player.PlayerEffects[1] = Last Created Entity;
		Wait(2, Ignore Condition);
		Destroy Effect(Event Player.PlayerEffects[1]);
	}
}

rule("Bounce when near pad 4")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Distance Between(Position Of(Event Player), Global.BouncePad4) <= 2.750;
		Event Player.BouncePadCooldown == 0;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Has Status(Event Player, Knocked Down) == False;
	}

	actions
	{
		Event Player.IsDashEnabled = True;
		If(Event Player.DashNerf);
			Apply Impulse(Event Player, Up, Global.BouncePadStrength - Global.BouncePadSuperjumpNerf, To World, Cancel Contrary Motion);
		Else;
			Apply Impulse(Event Player, Up, Global.BouncePadStrength, To World, Cancel Contrary Motion);
		End;
		Event Player.BouncePadCooldown = Global.BouncePadCooldownLength;
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Global.BouncePad1, 25);
		Event Player.PlayerEffects[1] = Last Created Entity;
		Wait(2, Ignore Condition);
		Destroy Effect(Event Player.PlayerEffects[1]);
	}
}

rule("Ball delete requested")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BallDeleteRequested == True;
	}

	actions
	{
		Global.BallDeleteRequested = False;
		Global.SlotOfTargetedPlayer = -1;
		Stop Chasing Global Variable(BallDirection);
		Stop Chasing Global Variable(BallPosition);
		Stop Chasing Global Variable(BallSpeed);
		Global.BallPosition = Vector(0, -1, 0);
		Global.BallDirection = Vector(0, 0, 0);
		Global.BallIsOut = False;
		Global.SlotOfPreviousTargetedPlayer = -1;
		Global.BallSpawnCountdown = 2;
		Global.PrevBallPos = Vector(0, 0, 0);
		Global.PrevBallPos2 = Vector(0, 0, 0);
	}
}

rule("Only end game when there isn't a round in progress")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Match Time == 0;
		Global.RoundInProgress == False;
		Global.GameEndEnabled == True;
		Global.TieBreakerActive == False;
	}

	actions
	{
		Enable Built-In Game Mode Music;
		Enable Built-In Game Mode Completion;
	}
}

rule("primary = dash")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Custom String("{0}", Event Player) != Custom String("bytestats");
	}

	actions
	{
		Press Button(Event Player, Button(Ability 1));
	}
}

rule("secondary = deflect")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Custom String("{0}", Event Player) != Custom String("bytestats");
		Global.PassingEnabled == False;
	}

	actions
	{
		Press Button(Event Player, Button(Ability 2));
	}
}

rule("Start round")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsEnoughPlayersToStart == True;
		Is Game In Progress == True;
		Current Game Mode == Game Mode(Deathmatch);
	}

	actions
	{
		Chase Global Variable At Rate(BallSpawnCountdown, 0, 1, Destination and Rate);
		Global.RoundInProgress = True;
		Chase Player Variable At Rate(All Players(All Teams), BouncePadCooldown, 0, 1, Destination and Rate);
		Global.BallSpawnCountdown = 5;
	}
}

rule("Start round - TEAMS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsEnoughPlayersToStart == True;
		Is Game In Progress == True;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		Chase Global Variable At Rate(BallSpawnCountdown, 0, 1, Destination and Rate);
		Global.RoundInProgress = True;
		Chase Player Variable At Rate(All Players(All Teams), BouncePadCooldown, 0, 1, Destination and Rate);
		Global.BallSpawnCountdown = 5;
	}
}

rule("Spawn ball")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BallSpawnCountdown == 0;
	}

	actions
	{
		Global.BallPosition = Global.CircleCenter;
		Global.BallDirection = Direction Towards(Global.BallPosition, Eye Position(Global.SlotOfTargetedPlayer));
		Global.BallSpeed = Min(30, Global.BallSpeed);
		Global.BallIsOut = True;
	}
}

rule("ball motion (has to be done weird due to chase vector variable bugs)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BallIsOut == True;
	}

	actions
	{
		Global.PrevBallPos2 = Global.PrevBallPos;
		Global.PrevBallPos = Global.BallPosition;
		Chase Global Variable At Rate(BallPosition, Global.BallPosition + Global.BallDirection * Global.BallSpeed, Global.BallSpeed,
			Destination and Rate);
		Chase Global Variable At Rate(BallDirection, Direction Towards(Global.BallPosition, Eye Position(Global.SlotOfTargetedPlayer)),
			1.750, Destination and Rate);
		Chase Global Variable At Rate(BallSpeed, Global.MaxBallSpeed, 0.250, Destination and Rate);
		Wait(0.050, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Ball reaches player")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Distance Between(Global.BallPosition, Eye Position(Global.SlotOfTargetedPlayer)) <= 1.900;
		Global.BallIsOut == True;
		Current Game Mode == Game Mode(Deathmatch);
	}

	actions
	{
		If(Is Button Held(Global.SlotOfTargetedPlayer, Button(Secondary Fire)));
			"If they don't have enough health, kill em"
			If(Health(Global.SlotOfTargetedPlayer) <= 100);
				Call Subroutine(DeflectFailed);
				Abort;
			End;
		End;
		Skip If(Is Using Ability 2(Global.SlotOfTargetedPlayer) || Is Using Ability 1(Global.SlotOfTargetedPlayer), 2);
		Call Subroutine(DeflectFailed);
		Abort;
		"if SlotOfTargetedPlayer.isUsingAbility2() or SlotOfTargetedPlayer.isUsingAbility1():\r\n        goto lbl_1"
		If(Is Using Ability 1(Global.SlotOfTargetedPlayer));
			Set Status(Global.SlotOfTargetedPlayer, Null, Knocked Down, 1);
			Teleport(Global.SlotOfTargetedPlayer, Global.BallPosition);
		End;
		Global.SlotOfTargetedPlayer.CurrentUltPercent += 5;
		Play Effect(All Players(All Teams), Explosion Sound, Color(White), Position Of(Global.SlotOfTargetedPlayer), 200);
		Global.SlotOfTargetedPlayer.PlayerDeflects += 1;
		Global.SlotOfPreviousTargetedPlayer = Global.SlotOfTargetedPlayer;
		Global.BallSpeed = Min(500, Global.BallSpeed * 1.050);
		If(Global.BallSpeed > Global.SlotOfTargetedPlayer.maxBallSpeed);
			Global.SlotOfTargetedPlayer.maxBallSpeed = Global.BallSpeed;
		End;
		Stop Chasing Global Variable(BallDirection);
		Global.BallDirection = Facing Direction Of(Global.SlotOfTargetedPlayer);
		Wait(0.001, Ignore Condition);
		If(Is Button Held(Global.SlotOfPreviousTargetedPlayer, Button(Secondary Fire)) && Global.PassingEnabled);
			Global.IsPassingTeam1 = True;
			Play Effect(All Players(All Teams), Ring Explosion, Color(Sky Blue), Position Of(Global.SlotOfPreviousTargetedPlayer), 10);
			Play Effect(Global.SlotOfPreviousTargetedPlayer, Moira Fade Disappear Sound, Color(White), Position Of(
				Global.SlotOfPreviousTargetedPlayer), 100);
			Set Player Health(Global.SlotOfPreviousTargetedPlayer, Global.PassingDamage);
			Global.SlotOfTargetedPlayer = Global.SlotOfPreviousTargetedPlayer;
		Else;
			Global.IsPassingTeam1 = False;
			Heal(Global.SlotOfPreviousTargetedPlayer, Null, Global.PassingDamage);
			Global.SlotOfTargetedPlayer = First Of(Sorted Array(Remove From Array(All Living Players(All Teams),
				Global.SlotOfPreviousTargetedPlayer), Angle Between Vectors(Facing Direction Of(Global.SlotOfTargetedPlayer),
				Direction Towards(Global.SlotOfTargetedPlayer, Position Of(Current Array Element)))));
		End;
		Chase Global Variable At Rate(BallDirection, Direction Towards(Global.BallPosition, Eye Position(Global.SlotOfTargetedPlayer)), 6,
			Destination and Rate);
	}
}

rule("Ball reaches player -TEAMS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Distance Between(Global.BallPosition, Eye Position(Global.SlotOfTargetedPlayer)) <= 1.900;
		Global.BallIsOut == True;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		If(Is Button Held(Global.SlotOfTargetedPlayer, Button(Secondary Fire)));
			"If they don't have enough health, kill em"
			If(Health(Global.SlotOfTargetedPlayer) <= 100);
				Call Subroutine(DeflectFailed);
				Abort;
			End;
		End;
		Skip If(Is Using Ability 2(Global.SlotOfTargetedPlayer) || Is Using Ability 1(Global.SlotOfTargetedPlayer), 2);
		Call Subroutine(DeflectFailed);
		Abort;
		"if SlotOfTargetedPlayer.isUsingAbility2() or SlotOfTargetedPlayer.isUsingAbility1():\r\n        goto lbl_1"
		If(Is Using Ability 1(Global.SlotOfTargetedPlayer));
			Set Status(Global.SlotOfTargetedPlayer, Null, Knocked Down, 1);
			Teleport(Global.SlotOfTargetedPlayer, Global.BallPosition);
		End;
		Global.SlotOfTargetedPlayer.CurrentUltPercent += 5;
		Play Effect(All Players(All Teams), Explosion Sound, Color(White), Position Of(Global.SlotOfTargetedPlayer), 200);
		Global.SlotOfTargetedPlayer.PlayerDeflects += 1;
		Global.SlotOfPreviousTargetedPlayer = Global.SlotOfTargetedPlayer;
		Global.BallSpeed = Min(500, Global.BallSpeed * 1.050);
		If(Global.BallSpeed > Global.SlotOfTargetedPlayer.maxBallSpeed);
			Global.SlotOfTargetedPlayer.maxBallSpeed = Global.BallSpeed;
		End;
		Stop Chasing Global Variable(BallDirection);
		Global.BallDirection = Facing Direction Of(Global.SlotOfTargetedPlayer);
		Wait(0.001, Ignore Condition);
		If(Is Button Held(Global.SlotOfPreviousTargetedPlayer, Button(Secondary Fire)) && Global.PassingEnabled);
			"if SlotOfPreviousTargetedPlayer.isHoldingButton(Button.SECONDARY_FIRE):"
			Play Effect(All Players(All Teams), Ring Explosion, Color(Sky Blue), Position Of(Global.SlotOfPreviousTargetedPlayer), 10);
			Play Effect(Global.SlotOfPreviousTargetedPlayer, Moira Fade Disappear Sound, Color(White), Position Of(
				Global.SlotOfPreviousTargetedPlayer), 100);
			Set Player Health(Global.SlotOfPreviousTargetedPlayer, Global.PassingDamage);
			"Check which team is passing"
			If(Team Of(Global.SlotOfPreviousTargetedPlayer) == Team 1);
				Global.IsPassingTeam1 = True;
			Else;
				Global.IsPassingTeam2 = True;
			End;
			"If the member is the only one left on their team, self pass"
			If(Number Of Living Players(Team Of(Global.SlotOfPreviousTargetedPlayer)) == 1);
				Global.SlotOfTargetedPlayer = Global.SlotOfPreviousTargetedPlayer;
			Else;
				Global.SlotOfTargetedPlayer = First Of(Sorted Array(Remove From Array(All Living Players(Team Of(
					Global.SlotOfPreviousTargetedPlayer)), Global.SlotOfPreviousTargetedPlayer), Angle Between Vectors(Facing Direction Of(
					Global.SlotOfTargetedPlayer), Direction Towards(Global.SlotOfTargetedPlayer, Position Of(Current Array Element)))));
			End;
		Else;
			Heal(Global.SlotOfPreviousTargetedPlayer, Null, Global.PassingDamage);
			Global.IsPassingTeam1 = False;
			Global.IsPassingTeam2 = False;
			Global.SlotOfTargetedPlayer = First Of(Sorted Array(Remove From Array(All Living Players(Opposite Team Of(Team Of(
				Global.SlotOfPreviousTargetedPlayer))), Global.SlotOfPreviousTargetedPlayer), Angle Between Vectors(Facing Direction Of(
				Global.SlotOfTargetedPlayer), Direction Towards(Global.SlotOfTargetedPlayer, Position Of(Current Array Element)))));
		End;
		Chase Global Variable At Rate(BallDirection, Direction Towards(Global.BallPosition, Eye Position(Global.SlotOfTargetedPlayer)), 6,
			Destination and Rate);
	}
}

rule("Player Didn't Deflect - Kill")
{
	event
	{
		Subroutine;
		DeflectFailed;
	}

	actions
	{
		Heal(All Living Players(All Teams), Null, 200);
		Global.IsPassingTeam1 = False;
		Global.IsPassingTeam2 = False;
		Set Status(Global.SlotOfTargetedPlayer, Global.SlotOfPreviousTargetedPlayer, Stunned, 1);
		If(Global.ImprovedExplosions == True);
			Call Subroutine(UpdatedDeathEffects);
		Else;
			Call Subroutine(CoolDeathEffects);
		End;
		Global.SlotOfTargetedPlayer.BouncePadCooldown = 0;
		Global.SlotOfPreviousTargetedPlayer.CurrentUltPercent += 15;
		Kill(Global.SlotOfTargetedPlayer, Global.SlotOfPreviousTargetedPlayer);
		Global.SlotOfTargetedPlayer.PlayerDeaths += 1;
		Global.SlotOfPreviousTargetedPlayer.PlayerKills += 1;
		Global.BallDeleteRequested = True;
		Abort;
	}
}

rule("CoolDeathEffects sub")
{
	event
	{
		Subroutine;
		CoolDeathEffects;
	}

	actions
	{
		Create Beam Effect(All Players(All Teams), Bad Beam, Global.SlotOfPreviousTargetedPlayer, Global.SlotOfTargetedPlayer, Color(
			Sky Blue), Visible To Position and Radius);
		Global.deathBeam = Last Created Entity;
		Global.deathSpherePos = Position Of(Global.SlotOfTargetedPlayer);
		Global.deathSphereRad = 30;
		Chase Global Variable Over Time(deathSphereRad, 0, 0.250, Destination and Duration);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Sky Blue), Global.deathSpherePos, 40);
		Create Effect(All Players(All Teams), Sphere, Color(Black), Global.deathSpherePos, Global.deathSphereRad,
			Visible To Position and Radius);
		Global.deathSphere = Last Created Entity;
		Play Effect(All Players(All Teams), Good Explosion, Color(White), Global.deathSpherePos, 5);
		Wait(0.250, Ignore Condition);
		Destroy Effect(Global.deathSphere);
		"playEffect(getAllPlayers(), DynamicEffect.RING_EXPLOSION, Color.RED, deathSpherePos, SphereSize * 1.5)\r\nplayEffect(getAllPlayers(), DynamicEffect.EXPLOSION_SOUND, Color.WHITE, deathSpherePos, 40)"
		Destroy Effect(Global.deathBeam);
	}
}

rule("Updated Death Effects Sub")
{
	event
	{
		Subroutine;
		UpdatedDeathEffects;
	}

	actions
	{
		Global.deathSpherePos = Position Of(Global.SlotOfTargetedPlayer);
		"Make sure it is final duel AND there are at least 3 or more players"
		If(Number Of Living Players(All Teams) == 2 && Number Of Players(All Teams) != 2);
			If(Global.FinalDuelNuke);
				Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Effect, Color(White), Vector(X Component Of(
					Global.deathSpherePos), 0, Z Component Of(Global.deathSpherePos)), 0);
			End;
		End;
		Play Effect(All Players(All Teams), Bastion Tank Cannon Explosion Effect, Color(White), Global.deathSpherePos, 1);
		If(Global.RandomExplosionSounds);
			"Pick a random explosion sound"
			Global.RandomExplosionPicker = Random Integer(0, 4);
			If(Global.RandomExplosionPicker == 0);
				Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Color(White), Global.deathSpherePos,
					Global.ExplosionSoundVolume);
			Else If(Global.RandomExplosionPicker == 1);
				Play Effect(All Players(All Teams), Bastion Tank Cannon Explosion Sound, Color(White), Global.deathSpherePos,
					Global.ExplosionSoundVolume);
			Else If(Global.RandomExplosionPicker == 2);
				Play Effect(All Players(All Teams), Ashe Dynamite Explosion Sound, Color(White), Global.deathSpherePos,
					Global.ExplosionSoundVolume);
			Else If(Global.RandomExplosionPicker == 3);
				Play Effect(All Players(All Teams), Pharah Barrage Explosion Sound, Color(White), Global.deathSpherePos,
					Global.ExplosionSoundVolume);
			Else If(Global.RandomExplosionPicker == 4);
				Play Effect(All Players(All Teams), Junkrat Frag Launcher Explosion Sound, Color(White), Global.deathSpherePos,
					Global.ExplosionSoundVolume);
			End;
		Else;
			"playEffect(getAllPlayers(), DynamicEffect.DOOMFIST_METEOR_STRIKE_IMPACT_SOUND, Color.WHITE, deathSpherePos, ExplosionSoundVolume)"
			Play Effect(All Players(All Teams), Junkrat Frag Launcher Explosion Sound, Color(White), Global.deathSpherePos,
				Global.ExplosionSoundVolume);
	}
}

rule("Final duel")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Count Of(Filtered Array(All Living Players(All Teams), Current Array Element.hasMoved)) == 2;
		Global.IsEnoughPlayersToStart == True;
		Global.IsInFinalDuel == False;
		Current Game Mode == Game Mode(Deathmatch);
	}

	actions
	{
		All Living Players(All Teams).IsDashEnabled = False;
		Skip If(Global.BallIsOut == False, 1);
		Global.BallDeleteRequested = True;
		Global.IsInFinalDuel = True;
		All Living Players(All Teams).BouncePadCooldown = 2;
		Skip If(Number Of Players(All Teams) <= 2, 1);
		Big Message(All Players(All Teams), Custom String("Final Duel!"));
		Apply Impulse(All Living Players(All Teams), Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Backward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Left, 0.001, To World, Cancel Contrary Motion);
		If(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night));
			Teleport(First Of(All Living Players(All Teams)), Global.CircleCenter + Vector(-1, 0, 0) * (Global.SphereSize / 4));
			Teleport(All Living Players(All Teams)[1], Global.CircleCenter + Vector(1, 0, 0) * (Global.SphereSize / 4));
		Else;
			Teleport(First Of(All Living Players(All Teams)), Global.CircleCenter + Vector(-1, 0, 0) * (Global.SphereSize / 1.500));
			Teleport(All Living Players(All Teams)[1], Global.CircleCenter + Vector(1, 0, 0) * (Global.SphereSize / 1.500));
		End;
		Set Status(All Living Players(All Teams), Null, Rooted, 2);
		Wait(0.001, Ignore Condition);
		Set Facing(First Of(All Living Players(All Teams)), Direction Towards(Position Of(First Of(All Living Players(All Teams))),
			Global.CircleCenter), To World);
		Set Facing(All Living Players(All Teams)[1], Direction Towards(Position Of(All Living Players(All Teams)[1]), Global.CircleCenter),
			To World);
	}
}

rule("Final duel - TEAMS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Count Of(Filtered Array(All Living Players(Team 1), Current Array Element.hasMoved)) == 1;
		Count Of(Filtered Array(All Living Players(Team 2), Current Array Element.hasMoved)) == 1;
		Global.IsEnoughPlayersToStart == True;
		Global.IsInFinalDuel == False;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		All Living Players(All Teams).IsDashEnabled = False;
		Skip If(Global.BallIsOut == False, 1);
		Global.BallDeleteRequested = True;
		Global.IsInFinalDuel = True;
		All Living Players(All Teams).BouncePadCooldown = 2;
		Skip If(Number Of Players(All Teams) <= 2, 1);
		Big Message(All Players(All Teams), Custom String("Final Duel!"));
		Apply Impulse(All Living Players(All Teams), Down, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Up, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Backward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Forward, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Right, 0.001, To World, Cancel Contrary Motion);
		Apply Impulse(All Living Players(All Teams), Left, 0.001, To World, Cancel Contrary Motion);
		If(Current Map == Map(Workshop Island) || Current Map == Map(Workshop Island Night));
			Teleport(First Of(All Living Players(All Teams)), Global.CircleCenter + Vector(-1, 0, 0) * (Global.SphereSize / 4));
			Teleport(All Living Players(All Teams)[1], Global.CircleCenter + Vector(1, 0, 0) * (Global.SphereSize / 4));
		Else;
			Teleport(First Of(All Living Players(All Teams)), Global.CircleCenter + Vector(-1, 0, 0) * (Global.SphereSize / 1.500));
			Teleport(All Living Players(All Teams)[1], Global.CircleCenter + Vector(1, 0, 0) * (Global.SphereSize / 1.500));
		End;
		Set Status(All Living Players(All Teams), Null, Rooted, 2);
		Wait(0.001, Ignore Condition);
		Set Facing(First Of(All Living Players(All Teams)), Direction Towards(Position Of(First Of(All Living Players(All Teams))),
			Global.CircleCenter), To World);
		Set Facing(All Living Players(All Teams)[1], Direction Towards(Position Of(All Living Players(All Teams)[1]), Global.CircleCenter),
			To World);
	}
}

rule("Check for last player surviving")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Number Of Living Players(All Teams) == 1;
		Global.IsEnoughPlayersToStart == True;
		Current Game Mode == Game Mode(Deathmatch);
	}

	actions
	{
		Global.IsInFinalDuel = False;
		Modify Player Score(All Living Players(All Teams), 1);
		Wait(0.250, Ignore Condition);
		If((Match Time == 0 || Global.TieBreakerActive) && Global.GameEndEnabled);
			"If there is alredy a tiebreaker, then the tiebreaker has ended.\r\nif TieBreakerActive:\r\nbreak\r\n__end__()"
			Global.HighestScore = Score Of(Last Of(Sorted Array(All Players(All Teams), Score Of(Current Array Element))));
			"Check if there is more then 1 person with the highest score"
			If(Count Of(Filtered Array(All Players(All Teams), Score Of(Current Array Element) == Global.HighestScore)) > 1);
				"There is more then 1, activate tie breaker"
				Global.TieBreakerActive = True;
			Else;
				Global.TieBreakerActive = False;
			End;
		End;
		Stop Chasing Global Variable(BallSpawnCountdown);
		Stop Chasing Player Variable(All Players(All Teams), BouncePadCooldown);
		Big Message(All Players(All Teams), Custom String("{0} has won the round!", First Of(All Living Players(All Teams))));
		Wait(2, Ignore Condition);
		If(!Global.TieBreakerActive);
			Resurrect(All Dead Players(All Teams));
		Else;
			"Kill anyone alive who doesn't have the highest score."
			Kill(Filtered Array(All Living Players(All Teams), Score Of(Current Array Element) != Global.HighestScore), Null);
			"During tiebreaker, only revive the people who have the same score as the highest score."
			Resurrect(Filtered Array(All Dead Players(All Teams), Score Of(Current Array Element) == Global.HighestScore));
			Wait(0.250, Ignore Condition);
			Global.SlotOfTargetedPlayer = -1;
			Big Message(All Players(All Teams), Custom String("Tiebreaker!"));
		End;
		Abort If(!Global.IsEnoughPlayersToStart);
		Global.RoundInProgress = False;
		All Players(All Teams).BouncePadCooldown = Global.BouncePadCooldownLength;
		Global.SlotOfTargetedPlayer = -1;
		Global.BallSpawnCountdown = 5;
		Wait(1, Ignore Condition);
		Global.RoundInProgress = True;
		Skip If(!Global.BouncepadDashingEnabled, 2);
		All Players(All Teams).IsDashEnabled = False;
		Set Ability 1 Enabled(All Players(All Teams), False);
		Chase Global Variable At Rate(BallSpawnCountdown, 0, 1, Destination and Rate);
		Chase Player Variable At Rate(All Players(All Teams), BouncePadCooldown, 0, 1, Destination and Rate);
	}
}

rule("Team 1 Last Surviving")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Number Of Living Players(Team 2) == 0;
		Global.IsEnoughPlayersToStart == True;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		Global.IsInFinalDuel = False;
		Modify Team Score(Team 1, 1);
		Wait(0.250, Ignore Condition);
		If((Match Time == 0 || Global.TieBreakerActive) && Global.GameEndEnabled);
			"If there is alredy a tiebreaker, then the tiebreaker has ended.\r\nif TieBreakerActive:\r\nbreak\r\n__end__()"
			Global.HighestScore = Score Of(Last Of(Sorted Array(All Players(All Teams), Score Of(Current Array Element))));
			"Check if there is more then 1 person with the highest score"
			If(Team Score(Team 1) == Team Score(Team 2));
				"There is more then 1, activate tie breaker"
				Global.TieBreakerActive = True;
			Else;
				Global.TieBreakerActive = False;
			End;
		End;
		Stop Chasing Global Variable(BallSpawnCountdown);
		Stop Chasing Player Variable(All Players(All Teams), BouncePadCooldown);
		Big Message(All Players(All Teams), Custom String("{0} has won the round!", Team 1));
		Wait(2, Ignore Condition);
		If(!Global.TieBreakerActive);
			Resurrect(All Dead Players(All Teams));
		Else;
			"Kill anyone alive who doesn't have the highest score."
			Kill(Filtered Array(All Living Players(All Teams), Score Of(Current Array Element) != Global.HighestScore), Null);
			"During tiebreaker, only revive the people who have the same score as the highest score."
			Resurrect(Filtered Array(All Dead Players(All Teams), Score Of(Current Array Element) == Global.HighestScore));
			Wait(0.250, Ignore Condition);
			Global.SlotOfTargetedPlayer = -1;
			Big Message(All Players(All Teams), Custom String("Tiebreaker!"));
		End;
		Heal(All Players(All Teams), Null, 200);
		Abort If(!Global.IsEnoughPlayersToStart);
		Global.RoundInProgress = False;
		All Players(All Teams).BouncePadCooldown = Global.BouncePadCooldownLength;
		Global.SlotOfTargetedPlayer = -1;
		Global.BallSpawnCountdown = 5;
		Wait(1, Ignore Condition);
		Global.RoundInProgress = True;
		Skip If(!Global.BouncepadDashingEnabled, 2);
		All Players(All Teams).IsDashEnabled = False;
		Set Ability 1 Enabled(All Players(All Teams), False);
		Chase Global Variable At Rate(BallSpawnCountdown, 0, 1, Destination and Rate);
		Chase Player Variable At Rate(All Players(All Teams), BouncePadCooldown, 0, 1, Destination and Rate);
	}
}

rule("Team 2 Last Surviving")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Number Of Living Players(Team 1) == 0;
		Global.IsEnoughPlayersToStart == True;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		Global.IsInFinalDuel = False;
		Modify Team Score(Team 2, 1);
		Wait(0.250, Ignore Condition);
		If((Match Time == 0 || Global.TieBreakerActive) && Global.GameEndEnabled);
			"If there is alredy a tiebreaker, then the tiebreaker has ended.\r\nif TieBreakerActive:\r\nbreak\r\n__end__()"
			Global.HighestScore = Score Of(Last Of(Sorted Array(All Players(All Teams), Score Of(Current Array Element))));
			"Check if there is more then 1 person with the highest score"
			If(Team Score(Team 1) == Team Score(Team 2));
				"There is more then 1, activate tie breaker"
				Global.TieBreakerActive = True;
			Else;
				Global.TieBreakerActive = False;
			End;
		End;
		Stop Chasing Global Variable(BallSpawnCountdown);
		Stop Chasing Player Variable(All Players(All Teams), BouncePadCooldown);
		Big Message(All Players(All Teams), Custom String("{0} has won the round!", Team 2));
		Wait(2, Ignore Condition);
		If(!Global.TieBreakerActive);
			Resurrect(All Dead Players(All Teams));
		Else;
			"Kill anyone alive who doesn't have the highest score."
			Kill(Filtered Array(All Living Players(All Teams), Score Of(Current Array Element) != Global.HighestScore), Null);
			"During tiebreaker, only revive the people who have the same score as the highest score."
			Resurrect(Filtered Array(All Dead Players(All Teams), Score Of(Current Array Element) == Global.HighestScore));
			Wait(0.250, Ignore Condition);
			Global.SlotOfTargetedPlayer = -1;
			Big Message(All Players(All Teams), Custom String("Tiebreaker!"));
		End;
		Heal(All Players(All Teams), Null, 200);
		Abort If(!Global.IsEnoughPlayersToStart);
		Global.RoundInProgress = False;
		All Players(All Teams).BouncePadCooldown = Global.BouncePadCooldownLength;
		Global.SlotOfTargetedPlayer = -1;
		Global.BallSpawnCountdown = 5;
		Wait(1, Ignore Condition);
		Global.RoundInProgress = True;
		Skip If(!Global.BouncepadDashingEnabled, 2);
		All Players(All Teams).IsDashEnabled = False;
		Set Ability 1 Enabled(All Players(All Teams), False);
		Chase Global Variable At Rate(BallSpawnCountdown, 0, 1, Destination and Rate);
		Chase Player Variable At Rate(All Players(All Teams), BouncePadCooldown, 0, 1, Destination and Rate);
	}
}

rule("Player check")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Custom String("{0}", Event Player) == Custom String("daboss");
	}

	actions
	{
		Kill(Event Player, Null);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("All players dead failsafe")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Number Of Living Players(All Teams) == 0;
		Is Game In Progress == True;
		Global.TieBreakerActive == False;
	}

	actions
	{
		Global.IsInFinalDuel = False;
		Skip If(Global.BallIsOut == False, 1);
		Global.BallDeleteRequested = True;
		Global.RoundInProgress = False;
		Stop Chasing Global Variable(BallSpawnCountdown);
		Resurrect(All Dead Players(All Teams));
		Small Message(All Players(All Teams), Custom String("All players detected dead! Resetting game."));
		Stop Chasing Player Variable(All Players(All Teams), BouncePadCooldown);
		All Players(All Teams).BouncePadCooldown = Global.BouncePadCooldownLength;
		Global.BallSpawnCountdown = 5;
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Wait(2, Ignore Condition);
		Abort If(!Global.IsEnoughPlayersToStart);
		Chase Player Variable At Rate(All Players(All Teams), BouncePadCooldown, 0, 1, Destination and Rate);
		Chase Global Variable At Rate(BallSpawnCountdown, 0, 1, Destination and Rate);
		Global.RoundInProgress = True;
		Global.BallPosition = Vector(0, -1, 0);
	}
}

rule("dash slow")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.DashNerf = True;
		Event Player.moveSpeed = 0;
		Chase Player Variable At Rate(Event Player, moveSpeed, 100, Max(Event Player.moveSpeed, 16) ^ 1.250, Destination and Rate);
		While(Event Player.moveSpeed != 100);
			Set Move Speed(Event Player, Event Player.moveSpeed);
			Set Gravity(Event Player, Event Player.moveSpeed);
			Wait(0.100, Ignore Condition);
		End;
		Set Move Speed(Event Player, 100);
		Set Gravity(Event Player, 100);
		Event Player.DashNerf = False;
	}
}

rule("Ball bounce off surface")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BallIsOut == True;
		Ray Cast Hit Position(Global.BallPosition, Global.BallPosition + Global.BallDirection * Global.BallSpeed * 0.033, Null,
			All Players(All Teams), False) != Global.BallPosition + Global.BallDirection * Global.BallSpeed * 0.033;
		Current Map != Map(Workshop Chamber);
	}

	actions
	{
		"normal of the plane of the surface with which the ball collides, n"
		Global.BallCollisionSurfaceNormal = Ray Cast Hit Normal(Global.BallPosition,
			Global.BallPosition + Global.BallDirection * Global.BallSpeed * 0.066, Null, All Players(All Teams), False);
		"reflected vector formula --- new v = v - 2 * (v•n)/(n•n) * n"
		Global.BallDirection -= 2 * Global.BallDirection * Global.BallCollisionSurfaceNormal / Dot Product(
			Global.BallCollisionSurfaceNormal, Global.BallCollisionSurfaceNormal) * Global.BallCollisionSurfaceNormal;
		Play Effect(All Players(All Teams), Bad Explosion, Color(White), Global.BallPosition, 1);
		Wait(0.020, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Ball no down when y < -0.5")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BallIsOut == True;
		Y Component Of(Global.BallPosition) < -0.500;
		Y Component Of(Global.BallDirection) < 0;
	}

	actions
	{
		Global.BallDirection *= Vector(1, 0, 1);
		Play Effect(All Players(All Teams), Ring Explosion, Color(White), Global.BallPosition, 2);
	}
}

rule("Ball change color")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"createBeam(getAllPlayers(), Beam.BAD, PrevBallPos, PrevBallPos2, Color.GREEN, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)\r\nBallTail2 = getLastCreatedEntity()\r\nBallColor = 1\r\nelif BallColor != 2 and BallSpeed >= 25 and BallSpeed < 30:"
		Destroy Effect(Global.BallSmoke);
		Destroy Effect(Global.BallTail1);
		Destroy Effect(Global.BallTail2);
		"createEffect(getAllPlayers(), Effect.BAD_AURA, Color.YELLOW, BallPosition, 1, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)\r\nBallSmoke = getLastCreatedEntity()"
		Create Beam Effect(All Players(All Teams), Bad Beam, Global.PrevBallPos, Global.BallPosition, Color(Sky Blue),
			Visible To Position and Radius);
		Global.BallTail1 = Last Created Entity;
		Create Beam Effect(All Players(All Teams), Bad Beam, Global.PrevBallPos, Global.PrevBallPos2, Color(Sky Blue),
			Visible To Position and Radius);
		Global.BallTail2 = Last Created Entity;
		Global.BallColor = 2;
		"BallTail1 = getLastCreatedEntity()\r\ncreateBeam(getAllPlayers(), Beam.BAD, PrevBallPos, PrevBallPos2, Color.PURPLE, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)\r\nBallTail2 = getLastCreatedEntity()\r\nBallColor = 5\r\n__end__()"
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Play Effect(All Players(All Teams), Bad Explosion, Color(Green), Global.BallPosition, 2);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Yellow), Global.BallPosition, 2);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Global.BallPosition, 2);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Global.BallPosition, 2);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Purple), Global.BallPosition, 4);
	}
}

rule("Chamber x collision")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"This collision is the lazy way but its only for chamber so who cares"
		Current Map == Map(Workshop Chamber);
		Global.BallIsOut == True;
		(X Component Of(Global.BallPosition) + 0.400 >= 20 || X Component Of(Global.BallPosition) - 0.400 <= -20) == True;
	}

	actions
	{
		If((X Component Of(Global.BallPosition) + 0.400 >= 20 && X Component Of(Global.BallDirection) > 0) || (X Component Of(
			Global.BallPosition) - 0.400 <= -20 && X Component Of(Global.BallDirection) < 0));
			Global.BallDirection = Vector(X Component Of(Global.BallDirection) * -1, Y Component Of(Global.BallDirection), Z Component Of(
				Global.BallDirection));
			Play Effect(All Players(All Teams), Bad Explosion, Color(White), Global.BallPosition, 1);
		End;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Chamber y collision")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Workshop Chamber);
		Global.BallIsOut == True;
		(Y Component Of(Global.BallPosition) + 0.400 >= 40) - (Y Component Of(Global.BallPosition) - 0.400 <= 0) == True;
	}

	actions
	{
		If((Y Component Of(Global.BallPosition) + 0.400 >= 40 && Y Component Of(Global.BallDirection) > 0) || (Y Component Of(
			Global.BallPosition) - 0.400 <= 0 && Y Component Of(Global.BallDirection) < 0));
			Global.BallDirection = Vector(X Component Of(Global.BallDirection), Y Component Of(Global.BallDirection) * -1, Z Component Of(
				Global.BallDirection));
			Play Effect(All Players(All Teams), Bad Explosion, Color(White), Global.BallPosition, 1);
		End;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Chamber z collision")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Workshop Chamber);
		Global.BallIsOut == True;
		(Z Component Of(Global.BallPosition) + 0.400 >= 20 || Z Component Of(Global.BallPosition) - 0.400 <= -20) == True;
	}

	actions
	{
		If((Z Component Of(Global.BallPosition) + 0.400 >= 20 && Z Component Of(Global.BallDirection) > 0) || (Z Component Of(
			Global.BallPosition) - 0.400 <= -20 && Z Component Of(Global.BallDirection) < 0));
			Global.BallDirection = Vector(X Component Of(Global.BallDirection), Y Component Of(Global.BallDirection), Z Component Of(
				Global.BallDirection) * -1);
			Play Effect(All Players(All Teams), Bad Explosion, Color(White), Global.BallPosition, 1);
		End;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("No Undermaps")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Workshop Island Night);
		Global.BallIsOut == True;
		Y Component Of(Global.BallPosition) < -2.850;
		Y Component Of(Global.BallDirection) < 0;
	}

	actions
	{
		Global.BallDirection *= Vector(1, 0, 1);
		Play Effect(All Players(All Teams), Ring Explosion, Color(White), Global.BallPosition, 2);
	}
}

rule("Team 1 Win")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.AllowMatchEnd == True;
		Team Score(Team 1) == Global.ScoreToWin;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		Enable Built-In Game Mode Announcer;
		Declare Team Victory(Team 1);
	}
}

rule("Team 2 Win")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.AllowMatchEnd == True;
		Team Score(Team 2) == Global.ScoreToWin;
		Current Game Mode == Game Mode(Team Deathmatch);
	}

	actions
	{
		Enable Built-In Game Mode Announcer;
		Declare Team Victory(Team 2);
	}
}
